/**
 * This file is part of PandaCard, licensed under the MIT License (MIT)
 * 
 * Copyright (c) 2018 Brian Wood
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package io.github.redpanda4552.PandaCard.util;

import org.apache.commons.lang3.ArrayUtils;

/**
 * Adapted from 
 * <a href="https://github.com/PCSX2/pcsx2/blob/master/pcsx2/gui/MemoryCardFolder.cpp">PCSX2 folder memory cards</a>.
 * Which are an adaptation of 
 * <a href="http://www.oocities.org/siliconvalley/station/8269/sma02/sma02.html#ECC">whatever this is</a>.
 */
public class ECC {

    private final int DATA_BYTES = 128;
    
    private final int[] Table = {
            0x00, 0x87, 0x96, 0x11, 0xa5, 0x22, 0x33, 0xb4, 0xb4, 0x33, 0x22, 0xa5, 0x11, 0x96, 0x87, 0x00,
            0xc3, 0x44, 0x55, 0xd2, 0x66, 0xe1, 0xf0, 0x77, 0x77, 0xf0, 0xe1, 0x66, 0xd2, 0x55, 0x44, 0xc3,
            0xd2, 0x55, 0x44, 0xc3, 0x77, 0xf0, 0xe1, 0x66, 0x66, 0xe1, 0xf0, 0x77, 0xc3, 0x44, 0x55, 0xd2,
            0x11, 0x96, 0x87, 0x00, 0xb4, 0x33, 0x22, 0xa5, 0xa5, 0x22, 0x33, 0xb4, 0x00, 0x87, 0x96, 0x11,
            0xe1, 0x66, 0x77, 0xf0, 0x44, 0xc3, 0xd2, 0x55, 0x55, 0xd2, 0xc3, 0x44, 0xf0, 0x77, 0x66, 0xe1,
            0x22, 0xa5, 0xb4, 0x33, 0x87, 0x00, 0x11, 0x96, 0x96, 0x11, 0x00, 0x87, 0x33, 0xb4, 0xa5, 0x22,
            0x33, 0xb4, 0xa5, 0x22, 0x96, 0x11, 0x00, 0x87, 0x87, 0x00, 0x11, 0x96, 0x22, 0xa5, 0xb4, 0x33,
            0xf0, 0x77, 0x66, 0xe1, 0x55, 0xd2, 0xc3, 0x44, 0x44, 0xc3, 0xd2, 0x55, 0xe1, 0x66, 0x77, 0xf0,
            0xf0, 0x77, 0x66, 0xe1, 0x55, 0xd2, 0xc3, 0x44, 0x44, 0xc3, 0xd2, 0x55, 0xe1, 0x66, 0x77, 0xf0,
            0x33, 0xb4, 0xa5, 0x22, 0x96, 0x11, 0x00, 0x87, 0x87, 0x00, 0x11, 0x96, 0x22, 0xa5, 0xb4, 0x33,
            0x22, 0xa5, 0xb4, 0x33, 0x87, 0x00, 0x11, 0x96, 0x96, 0x11, 0x00, 0x87, 0x33, 0xb4, 0xa5, 0x22,
            0xe1, 0x66, 0x77, 0xf0, 0x44, 0xc3, 0xd2, 0x55, 0x55, 0xd2, 0xc3, 0x44, 0xf0, 0x77, 0x66, 0xe1,
            0x11, 0x96, 0x87, 0x00, 0xb4, 0x33, 0x22, 0xa5, 0xa5, 0x22, 0x33, 0xb4, 0x00, 0x87, 0x96, 0x11,
            0xd2, 0x55, 0x44, 0xc3, 0x77, 0xf0, 0xe1, 0x66, 0x66, 0xe1, 0xf0, 0x77, 0xc3, 0x44, 0x55, 0xd2,
            0xc3, 0x44, 0x55, 0xd2, 0x66, 0xe1, 0xf0, 0x77, 0x77, 0xf0, 0xe1, 0x66, 0xd2, 0x55, 0x44, 0xc3,
            0x00, 0x87, 0x96, 0x11, 0xa5, 0x22, 0x33, 0xb4, 0xb4, 0x33, 0x22, 0xa5, 0x11, 0x96, 0x87, 0x00
    };
    
    private byte[] ecc = new byte[16];
    private int offset = 0;
    
    public ECC(byte[] bytes, int startInclusive, int endExclusive) {
        nextGroup(ArrayUtils.subarray(bytes, startInclusive, endExclusive - 384));
        nextGroup(ArrayUtils.subarray(bytes, startInclusive + 128, endExclusive - 256));
        nextGroup(ArrayUtils.subarray(bytes, startInclusive + 256, endExclusive - 128));
        nextGroup(ArrayUtils.subarray(bytes, startInclusive + 384, endExclusive));
    }
    
    private void nextGroup(byte[] data) {
        if (data.length != DATA_BYTES) {
            System.err.println("ECC Group data mismatch (len = " + data.length + ", expected " + DATA_BYTES + ")");
            return;
        }
        
        int c;

        ecc[offset] = ecc[offset + 1] = ecc[offset + 2] = 0;

        for (int i = 0; i < 0x80; i++) {
            int pos = (int) data[i];
            
            if (pos < 0)
                pos += 256;
            
            c = Table[pos];

            ecc[offset] ^= c;
            
            if ((c & 0x80) == 1) {
                ecc[offset + 1] ^= ~i;
                ecc[offset + 2] ^= i;
            }
        }
        
        ecc[offset] = (byte) ~ecc[offset];
        ecc[offset] &= 0x77;

        ecc[offset + 1] = (byte) ~ecc[offset + 1];
        ecc[offset + 1] &= 0x7f;

        ecc[offset + 2] = (byte) ~ecc[offset + 2];
        ecc[offset + 2] &= 0x7f;
        
        offset += 3;
    }
    
    public byte[] get() {
        return ecc;
    }
}
